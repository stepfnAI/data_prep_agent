Step1 Data Gathering / preview and basic questionnaire 
    -Get the data from the user 
    -Ask user to upload the data and immediately run category identification agent and get it verified from the user
    -Then give option to add another data set and repeat above step till user clicks on all ‘tables uploaded and proceed to step2’
    -Ask user about the granularity of the problem statement we want to solve 
    -Product (its mandatory to have product level data in all uploaded tables in this case)
    -or Customer(default)
    
    -Validation
    -At least one billing table is must
    -And at least one from usage or support is must
    -Then send validation flag as True

    -Step1 output
        Billing_table:[table1],
        Usage_table:[table2],
        Support_table:[table3,table4]
        problem_statement_level:product/Customer
        step1_validation:True


Step2 data mapping step
    -Generate mapping suggestion based on uploaded data and its mapping
    -Get it confirmed from the user with constraint of mandatory mapping fields must be mapped as per category 
    -above this for all three category tables
    -Rename the columns with StdCols once confirmed

    -Step2 output
        mappedBillingData,
        mappedUsageData,
        MappedSupportData


Step3 data cleaning 
    -Generate cleaning suggestion for each of the table
    -Let user select, skip or manually instruct about cleaning step
    -Repeat for all three category tables

	Step3 output
        cleanedBillingData,
        cleanedUsageData,
        cleanedSupportData

Step4 data aggregation
    -Based on the problem statement level
    -Generate aggregation method suggestions and display the explanation for the same
    -Let user edit it with constrain of allowed methods per data type and confirm
    -Repeat for all three category tables

	Step4 output
        aggregatedBillingData,
        aggregatedUsageData,
        aggregatedSupportData


Step5 Data Joining

    1. Intra-Category Join Phase
        - Check if multiple tables exist within same category
        - If YES, perform intra-category joins first:
            - Billing tables: INNER JOIN on (BillingDate, CustomerID, ProductID*)
            - Usage tables: INNER JOIN on (UsageDate, CustomerID, ProductID*)
            - Support tables: INNER JOIN on (TicketOpenDate, CustomerID, ProductID*)
            * ProductID only if Analysis level is product
        - Result: One consolidated table per category

    2. Inter-Category Join Phase
        - Always keep Billing as the base (LEFT) table
        - For joining with other categories:
            
            A. Two Category Scenario (Billing + 1 other):
                - Simple left join with either Usage or Support
                - Join mappings:
                    - Dates: BillingDate <--> UsageDate/TicketOpenDate
                    - Customer: CustomerID <--> CustomerID
                    - Product: ProductID <--> ProductID (if Product level)
            
            B. Three Category Scenario (Billing + Usage + Support):
                - Interactive Join Order Selection:
                    1. Display Join Analysis Dashboard:
                        - For Usage Table:
                            - Unique Customer Count
                            - Date Range Coverage
                            - Overlap with Billing CustomerIDs (%)
                            - Date Range Overlap with Billing
                        - For Support Table:
                            - Unique Customer Count
                            - Date Range Coverage
                            - Overlap with Billing CustomerIDs (%)
                            - Date Range Overlap with Billing
                    
                    2. User Selection:
                        - Let user choose which table to join first based on the metrics
                        - Options:
                            "Join Usage First" OR "Join Support First"
                    
                    3. Execute Joins Based on Selection:
                        If "Join Usage First":
                            1. Billing LEFT JOIN Usage
                            2. Result LEFT JOIN Support
                        If "Join Support First":
                            1. Billing LEFT JOIN Support
                            2. Result LEFT JOIN Usage

                - Join Health Checks after each join:
                    - Monitor record counts pre/post join
                    - Check for data loss percentage
                    - Verify date range overlaps
                    - Validate key field matching rates

    3. Post-Join Processing
        - Handle duplicate column names from joins
        - Add join metadata columns (optional):
            - has_usage_data: Boolean
            - has_support_data: Boolean
        - Generate join summary report:
            - Initial record counts
            - Final record counts
            - Match rates
            - Date range coverage

    4. Validation Rules
        - Ensure no complete data loss after joins
        - Verify all mandatory fields are present
        - Check if granularity level is maintained
        - Validate date alignment across categories

    5. Output
        - final_joined_table
        - join_summary_report
        - validation_status 